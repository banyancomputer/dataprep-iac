/* main.tf: Deploys our service with the desired configuration */

# Terraform Config
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 4.0"
    }
  }
  required_version = "~> 1.3.0"

  # Our Remote State for Terraform on AWS
  # This bucket already exists in our AWS account
  backend "s3" {
    bucket = "banyan-tf-remote-state"
    key    = "dataprep-test/terraform.tfstate"
    region = "us-east-2"
  }
}

variable "aws_region" {
  default = "us-east-2"
}

# Provider Configuration
provider "aws" {
  region = "us-east-2"
}

data "aws_availability_zones" "available" {}

# Random Strings for passwords and such
# Create a random string to keep track of deployments
resource "random_string" "deploy_id" {
  length  = 8
  special = false
  upper   = false
}

# The name of our service
variable "service_name" {
  default = "dataprep-benchmark"
}

# What device name to use for the input volume
# Don't change this unless you know what you're doing
variable "INPUT_DEVICE" {
  default     = "/dev/sdf"
  description = "The device name for the input volume"
}

# What device name to use for the packed volume
# Don't change this unless you know what you're doing
variable "PACKED_DEVICE" {
  default     = "/dev/sdg"
  description = "The device name for the packed volume"
}

# What device name to use for the unpacked volume
# Don't change this unless you know what you're doing
variable "UNPACKED_DEVICE" {
  default     = "/dev/sdh"
  description = "The device name for the unpacked volume"
}

/* Deploy the infrastructure for our service */
module "service" {
  source = "./service"

  # AWS configuration
  aws_region            = "us-east-2"
  aws_availability_zone = data.aws_availability_zones.available.names[0]
  # Service configuration
  name                  = var.service_name
  deploy_id             = random_string.deploy_id.result

  ## CONFIGURE THESE FOR YOUR OWN BENCHMARKING PURPOSES ##

  # Ec2 configuration
  ec2_config = {
    # The instance type we want to use. This is a 32 core ARM instance.
    instance_type = "r6g.8xlarge"
    # The tenancy for this instance. Your AWS account may not have enough capacity to run this instance type with a dedicated tenancy.
    tenancy       = "dedicated"
    # The AMI we want to use for our instance. This filter for Amazon Linux 2 AMI for ARM64.
    ami_filter    = "amzn2-ami-hvm-*-arm64-gp2"
    # The volume type of instance storage.
    volume_type   = "gp2"
    # The size of the instance storage in GiB. This should be able to hold manifests and results.
    volume_size   = "50"
    # Do we want to monitor the instance? Usually not.
    monitoring = false
  }

  # EBS configuration
  ebs_config = {
    # The type of EBS volume we want to use
    type                 = "st1"
    # The device names to set for the EBS volumes
    input_device_name    = var.INPUT_DEVICE
    packed_device_name   = var.PACKED_DEVICE
    unpacked_device_name = var.UNPACKED_DEVICE

    # The sizes to allocate for the EBS volumes in GiB
    # Note: Be sure to account for Filesystem overhead when setting these values
    #       We set ext4 as the filesystem for the EBS volumes (~5% overhead)
    # Note: Be sure to think about what sort of data you're going to be storing on these volumes,
    #       and how they might be affected by the implementation of `dataprep` on the device.
    #       For example, random utf8 files will not compress well, possibly requiring more space in the packed volume.
    input_volume_size    = 125 # 120 GiB
    packed_volume_size   = 125 # 120 GiB
    unpacked_volume_size = 125 # 120 GiB
  }
}
# This is a hack to make sure the Ansible inventory is generated after the EC2 instance is created
resource "null_resource" "ansible_inventory" {
  depends_on = [module.service]
  triggers   = {
    ec2_public_dns = module.service.ec2_public_dns
    ec2_pem_path   = module.service.ec2_pem_path
    this_once      = true
  }
  # Overwrite ../inventory/aws/host with the public DNS of the EC2 instance and the path to the PEM file
  # Overwrite ../env.ssh with the public DNS of the EC2 instance and the path to the PEM file
  provisioner "local-exec" {
    command = <<-EOT
      echo '# This file is autogenerated by terraform' > ../env.ssh
      echo 'EC2_PEM_PATH=${module.service.ec2_pem_path}' >> ../env.ssh
      echo 'EC2_PUBLIC_DNS=${module.service.ec2_public_dns}' >> ../env.ssh
      echo '${module.service.ec2_public_dns} ansible_ssh_private_key_file=${module.service.ec2_pem_path}' > ../host
    EOT
  }
}
# Outputs
output "ec2_public_dns" {
  value = module.service.ec2_public_dns
}
output "ec2_pem_path" {
  value = module.service.ec2_pem_path
}